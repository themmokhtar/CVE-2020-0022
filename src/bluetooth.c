#include "bluetooth.h"

#include "log.h"
#include "errors.h"

#include <stdint.h>
#include <stddef.h>
#include <sys/uio.h>
// #include <sys/socket.h>

#include <bluetooth/bluetooth.h>
#include <bluetooth/hci.h>
#include <bluetooth/hci_lib.h>
#include <bluetooth/l2cap.h>

// struct bluetooth_l2cap_socket
// {
// };

// struct bluetooth_l2cap_packet
// {
//     union
//     {
//         uint8_t raw[1];
//         struct
//         {
//             uint8_t type;
//         };
//     };
// };

err_t bluetooth_hci_create(int *hci_sock_fd)
{
    if(hci_sock_fd == NULL)
        ERR_RET("NULL_HCI_SOCK_FD", "Parameter hci_sock_fd cannot be NULL");

    // Get the device ID of the first available Bluetooth adapter
    int hci_dev_id = hci_get_route(NULL);
    if (hci_dev_id < 0)
        ERR_RET("HCI_GET_ROUTE", "Failed to get device ID")
    // LOGL_VAR(hci_dev_id, "%d");

    // Get the device info of the first available Bluetooth adapter
    struct hci_dev_info hci_dev_info;
    if (hci_devinfo(hci_dev_id, &hci_dev_info) < 0)
        ERR_RET("HCI_DEVINFO", "Failed to get device info")
    // LOGL_VAR(hci_dev_info.dev_id, "%d");
    // LOGL_INFO("Using HCI Device %" PRIu16 ": %s (%02X:%02X:%02X:%02X:%02X:%02X)\n", hci_dev_info.dev_id, hci_dev_info.name, hci_dev_info.bdaddr.b[5], hci_dev_info.bdaddr.b[4], hci_dev_info.bdaddr.b[3], hci_dev_info.bdaddr.b[2], hci_dev_info.bdaddr.b[1], hci_dev_info.bdaddr.b[0]);

    // Open a socket to the first available Bluetooth adapter
    int _hci_sock_fd = hci_open_dev(hci_dev_id);
    if (_hci_sock_fd < 0)
        ERR_RET("HCI_OPEN_DEV", "Failed to open socket")
    LOGL_VAR(_hci_sock_fd, "%d");

    *hci_sock_fd = _hci_sock_fd;
    return NULL;
}

err_t bluetooth_hci_spoof_acl(const int hci_sock_fd, const uint16_t hci_handle, const uint8_t packet_id, const uint16_t continuation_size, const bool is_continuation, uint8_t *data, const uint16_t data_size)
{
    // HCI+ACL+L2CAP Packet format:
    // Append type, before the packet (HCI_ACLDATA_PKT)
    // HCI Header:      [0-1]   HCI Handle | Continuation Flags
    //                  [1-2]   len(acl_hdr) + len(l2cap_hdr) + len(data) = 4 + 4 + len(data) = 8 + len(data)
    // ACL Header:      [3-4]   len(l2cap_hdr) + len(data) = 4 + len(data)  [+2 for the second packet]
    //                  [5-6]   cid
    // L2CAP Header:    [7]     0x8
    //                  [8]     Packet Identifier (zero-indexed)
    //                  [9-10]  len(data)                                   [+2 for the second packet]
    //                  [...]   data

    if(hci_sock_fd < 0)
        ERR_RET("INVALID_HCI_SOCK_FD", "Parameter hci_sock_fd cannot be less than 0");

    struct 
    {
        uint8_t type; // This is technically not part of the packet, but it is necessary to identify the packet type
        struct {
            uint16_t handle;
            uint16_t len;
        } hci_header;
        struct {
            uint16_t len;
            uint16_t cid;
        } acl_header;
        struct {
            uint8_t code;
            uint8_t identifier;
            uint16_t len;
        } l2cap_header;
    } __attribute__((packed)) packet_header;

    // LOGL_VAR(sizeof(packet.hci_header), "%zu");
    packet_header.type = HCI_ACLDATA_PKT;

    packet_header.hci_header.handle = htobs(hci_handle | ((is_continuation ? 1 : 0) << 12));
    packet_header.hci_header.len = htobs(sizeof(packet_header.acl_header) + sizeof(packet_header.l2cap_header) + data_size);

    packet_header.acl_header.len = htobs(sizeof(packet_header.l2cap_header) + data_size + continuation_size);
    packet_header.acl_header.cid = htobs(1); // L2CAP Signaling Channel

    packet_header.l2cap_header.code = L2CAP_ECHO_REQ; // L2CAP Connection Parameter Update Request
    packet_header.l2cap_header.identifier = packet_id;
    packet_header.l2cap_header.len = htobs(data_size + continuation_size);

    // l2cap_cmd_hdr, l2cap_hdr

    struct iovec iov[2];

    iov[0].iov_base = &packet_header;
    iov[0].iov_len = sizeof(packet_header);
    iov[1].iov_base = data;
    iov[1].iov_len = data_size;

    while (writev(hci_sock_fd, iov, sizeof(iov) / sizeof(iov[0])) < 0)
    {
        if (errno == EAGAIN || errno == EINTR)
            continue;
        ERR_RET_SYS("WRITEV", "Failed to write to socket")
    }

    logl_hex((uint8_t *)&packet_header, sizeof(packet_header));
    logl_hex(data, data_size);

    return NULL;
}

err_t bluetooth_l2cap_create(int *l2cap_sock_fd)
{
    if (l2cap_sock_fd == NULL)
        ERR_RET("NULL_L2CAP_SOCK_FD", "Parameter l2cap_sock_fd cannot be NULL");

    int _l2cap_sock_fd = socket(AF_BLUETOOTH, SOCK_RAW, BTPROTO_L2CAP);
    if (_l2cap_sock_fd < 0)
        ERR_RET_SYS("SOCKET", "Failed to create socket")
    LOGL_VAR(_l2cap_sock_fd, "%d");

    *l2cap_sock_fd = _l2cap_sock_fd;
    return NULL;
}

err_t bluetooth_l2cap_connect(const int l2cap_sock_fd, const char *bdaddr_str, uint16_t *hci_handle)
{
    if (l2cap_sock_fd < 0)
        ERR_RET("INVALID_L2CAP_SOCK_FD", "Parameter l2cap_sock_fd cannot be less than 0");
    if (bdaddr_str == NULL)
        ERR_RET("NULL_BDADDR_STR", "Parameter bdaddr_str cannot be NULL");
    if (hci_handle == NULL)
        ERR_RET("NULL_HCI_HANDLE", "Parameter hci_handle cannot be NULL");

    // Convert the string representation of the Bluetooth address to a bdaddr_t
    bdaddr_t bdaddr;
    if (str2ba(bdaddr_str, &bdaddr) < 0)
        ERR_RET("STR2BA", "Failed to convert string to bdaddr_t")

    // Create a sockaddr_l2 struct representing the Bluetooth address to connect to
    struct sockaddr_l2 sockaddr;
    memset(&sockaddr, 0, sizeof(sockaddr));
    sockaddr.l2_family = AF_BLUETOOTH;
    sockaddr.l2_bdaddr = bdaddr;

    // Connect to the Bluetooth address
    if (connect(l2cap_sock_fd, (struct sockaddr *)&sockaddr, sizeof(sockaddr)) < 0)
        ERR_RET_SYS("CONNECT", "Failed to connect to Bluetooth address")

    // Get the connection info to note the HCI handle
    uint16_t _hci_handle;
    struct l2cap_conninfo conninfo;
    socklen_t conninfo_len = sizeof(conninfo);

    if (getsockopt(l2cap_sock_fd, SOL_L2CAP, L2CAP_CONNINFO, &conninfo, &conninfo_len) < 0)
        ERR_RET_SYS("GETSOCKOPT", "Failed to get connection info")
    _hci_handle = conninfo.hci_handle;
    LOGL_VAR(_hci_handle, "%" PRIu16);

    *hci_handle = _hci_handle;
    return NULL;
}

err_t bluetooth_l2cap_recv(const int l2cap_sock_fd, uint8_t *buffer, size_t buffer_max_size, size_t *read_amount)
{
    if (l2cap_sock_fd < 0)
        ERR_RET("INVALID_L2CAP_SOCK_FD", "Parameter l2cap_sock_fd cannot be less than 0");
    if (buffer == NULL)
        ERR_RET("NULL_BUFFER", "Parameter buffer cannot be NULL");
    if (buffer_max_size == 0)
        ERR_RET("ZERO_BUFFER_MAX_SIZE", "Parameter buffer_max_size cannot be 0");
    if (read_amount == NULL)
        ERR_RET("NULL_READ_AMOUNT", "Parameter read_amount cannot be NULL");
    
    ssize_t _read_amount = recv(l2cap_sock_fd, buffer, buffer_max_size, 0);
    if (_read_amount < 0)
        ERR_RET_SYS("RECV", "Failed to receive data")
    LOGL_VAR(_read_amount, "%zd");

    *read_amount = _read_amount;
    return NULL;
}