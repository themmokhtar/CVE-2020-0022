https://android.googlesource.com/platform/bionic/+/refs/tags/android-9.0.0_r49/libc/arch-arm64/generic/bionic/memcpy_base.S

We are tracing with a big nonnegative size value:
count = -2 = 0xFFFFFFFFFFFFFFFE

assume src = 0x1004, dstin = 0x2004

097: OK
098: srcend = src + count = 0x1004 + 0xFFFFFFFFFFFFFFFE = 0x1004 - 2 = 0x1002
099: dstend = dstin + count = 0x2004 + 0xFFFFFFFFFFFFFFFE = 0x2004 - 2 = 0x2002
100: OK
101: Branch if count <= 16 - NOT TAKEN
102: OK
103: Branch if count > 96 - TAKEN (to copy_long)

...

176: (copy_long)
177: tmp1 = dstin & 15 = 0x2004 & 0xF = 0x4
178: dst = dstin & (~15) = 0x2004 & (~0xF) = 0x2000
179: D = src[0:15]
180: src = src - tmp1 = 0x1004 - 0x4 = 0x1000
181: count = count + tmp1 = 0xFFFFFFFFFFFFFFFE + 0x4 = 0x2
182: A = src[16:31]
183: dstin[0:15] = D                                            // Copied 16 from 0x1004 to 0x2004
184: B = src[32:47]
185: C = src[48:63]
186: D = src[64:79], src = src[64:] = 0x1000 + 0x40 = 0x1040
187: count = count - (128 + 16) = 0x2 - 0x90 = 0x2 + 0xFFFFFFFFFFFFFF70 = 0xFFFFFFFFFFFFFF72
188: Branch if count < 0 - TAKEN (to 2)

...

204: (2)
205: E = srcend[-64:-49]
206: dst[16:31] = A                                             // Copied 16 from 0x1010 to 0x2010
207: A = srcend[-48:-33]
208: dst[32:47] = B                                             // Copied 16 from 0x1020 to 0x2020
209: B = srcend[-32:-17]
210: dst[48:63] = C                                             // Copied 16 from 0x1030 to 0x2030
211: C = srcend[-16:-1]
212: dst[64:79] = D                                             // Copied 16 from 0x1040 to 0x2040
213: dstend[-64:-49] = E                                        // Copied 16 from 0x0FC2 to 0x1FC2
214: dstend[-48:-33] = A                                        // Copied 16 from 0x0FD2 to 0x1FD2
215: dstend[-32:-17] = B                                        // Copied 16 from 0x0FE2 to 0x1FE2
216: dstend[-16:-1] = C                                         // Copied 16 from 0x0FF2 to 0x1FF2


So basically these are the copies that are being done, in order of the memory addresses:
0x0FC2 -> 0x1FC2 (16 bytes)
0x0FD2 -> 0x1FD2 (16 bytes)
0x0FE2 -> 0x1FE2 (16 bytes)
0x0FF2 -> 0x1FF2 (16 bytes)
0x1004 -> 0x2004 (16 bytes)
0x1010 -> 0x2010 (16 bytes)
0x1020 -> 0x2020 (16 bytes)
0x1030 -> 0x2030 (16 bytes)
0x1040 -> 0x2040 (16 bytes)

We can merge those copies into these regions:
0x0FC2 -> 0x1FC2 (64 bytes)
0x1004 -> 0x2004 (16 bytes)
0x1010 -> 0x2010 (64 bytes)

The last 2 regions have a 4-byte overlap, so we can merge them into a single region:
0x0FC2 -> 0x1FC2 (64 bytes)
0x1004 -> 0x2004 (76 bytes)

So the copies are (inclusive):
[0x0FC2, 0x1002)       COPIED TO       [0x1FC2, 0x2002)     (64 bytes)
[0x1004, 0x1050)       COPIED TO       [0x2004, 0x2050)     (76 bytes)

The destination should be something like this:
Copied To:      $
Copied From:    #
Left Unchanged: ?


Source:      [ ### 64 Bytes ### ] [ ??? 2 Bytes ??? ] !SRC ADDRESS! [ ### 76 Bytes ### ]
Destination: [ $$$ 64 Bytes $$$ ] [ ??? 2 Bytes ??? ] !DST ADDRESS! [ $$$ 76 Bytes $$$ ]

With this, we can do some good stuff:
 1. We can leak stuff that is before/after the source into the destination to be read
 2. We can corrupt the intended destination memory using the source
 3. We can corrupt stuff that is before/after the intended destination using the source 


